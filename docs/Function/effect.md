---
title: 纯函数与副作用
author: 向阳
date: 2023-04-19
---

## 函数式编程基本功：吃透“纯函数”与“副作用”

### 什么是纯函数

纯函数的学术定义：

> 纯函数（Pure Function）——输入输出数据流全是显式（Explicit）的函数。
> —— 维基百科

定义中的“显式”这个概念，其实非常好理解，它约束的是数据的来源（入参）和出口（返回值）。

- 数据以入参形式传入，这叫【显式输入数据流】。
- 数据以返回值形式输出，这叫【显式输出数据流】。

由此，我们可以把“学术定义”翻译为如下的大白话：

> 纯函数——输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，不以任何其它形式和外界进行数据交换的函数。

简单理解：同时满足以下两个特征的函数，我们就认为是纯函数：

- 对于相同的输入，总是会得到相同的输出。
- 在执行过程中没有语义上可观察的副作用。

### 什么是副作用

我们可以借助生活例子来理解：

> 药物副作用：为了治疗 A 疾病服用某种药物，药物在缓解 A 疾病的症状之余，可能会导致 B 疾病。那么“引发 B 疾病”就是这个药物的副作用。

对这句话稍作修改，便能够得到函数副作用的定义：

> 在计算机科学中，函数副作用指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——维基百科

简单地讲：对函数来说，它的正常工作任务就是【计算】，除了计算之外，它不应该搞别的。如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。

### 借助一些编码示例认识纯函数

案例一：加法函数

- add 函数并不是一个纯函数，因为对于相同的输入（输入指的是函数的入参，对于 add()函数来说，它的输入一直都是 void），但它无法做到相同的输出。

```js
//它的输入一直都是 void。但是第一次输出是30，第二次输出是50
let a = 10;
let b = 20;
function add() {
  return a + b;
}
add(); //30

a = 20;
b = 30;
add(); //50
```

- 只需要把“数据的输入”这件事情完全交给入参来做，就能够使 add 函数变为一个纯函数：
  - 对于相同的输入，总是会得到相同的输出：对于相同的 a 和 b 来说，它们的和总是相等的
  - 在执行过程中没有语义上可观察的副作用：add() 函数除了加法计算之外没有做任何事，不会对外部世界造成额外影响

```js
let a = 10;
let b = 20;

function add(a, b) {
  return a + b;
}

// 30
add(a, b);

a = 30;
b = 40;

// 70
add(a, b);
```

案例二：姓名处理函数

- processName 函数不是一个纯函数，因为 console.log() 会在控制台打印一行文字，这改变了浏览器的控制台，属于对外部世界的影响，也就是说 processName 函数在执行过程中产生了副作用。

```js
function processName(firstName, secondName) {
  const fullName = `${firstName}·${secondName}`;
  console.log(`I am ${fullName}`);
  return fullName;
}

processName("约瑟翰", "庞麦郎");
```

- 只需要像这样把副作用摘出去，就能使 processName 变为一个纯函数：

```js
function processName(firstName, secondName) {
  const fullName = `${firstName}·${secondName}`;
  return fullName;
}

console.log(processName("约瑟翰", "庞麦郎"));
```

案例三：网络请求函数

- getData 函数不是纯函数。一个引入了网络请求的函数，从原则上来说是纯不起来的。以示例代码中的 get 请求为例来分析：
  - 请求获取到的 response 是动态的：需要通过网络请求获取的数据往往是动态的，对于相同的输入，服务端未必能够给到相同的输出。
  - 请求可能出错：既然是网络请求，那就一定要考虑失败率的问题。网络拥塞、机房起火、后端删库跑路等等问题都有可能导致请求过程中的 Error，未经捕获的 Error 本身就是一种副作用。
- 当请求方法为 post、delete 等具有“写”能力的类型时，网络请求将会执行对外部数据的写操作，这会使函数的“不纯”更进一步。

```js
function getData(url) {
  const response = await fetch(url)
  const { data } = response
  return data
}
```

案例四：获取当天日期的函数

- getToday 函数不是纯函数，如果我明天、后天、大后天再来分别调用一次 getToday()，尽管输入都是 void，但输出却不一样。或者由于时区不同，即便我们都在同一个时刻执行 getToday()，两台电脑的输出也是截然不同的。

```js
function getToday() {
  return new Date().getDate();
}
```

由此我们可以看出，能够影响 JS 函数输出的因素太多了，函数入参只是众多因素中的一个。执行上下文中某个外部变量的变化、函数执行宿主的变化、系统时区的变化......甚至空气中温度、湿度的变化（JS 是可以调用传感器 API 的），都会影响 JS 函数的输出。

### 纯函数的意义

从不同的视角出发，我们确实会发现纯函数能够解决不少具体的小问题，归根结底还是因为它解决了两个大问题:`不确定性` 和 `副作用`。

#### 纯函数，高度确定的函数

不纯的函数（Impure function）最直接的问题就是不确定性：对于同样的输入，不能够保证同样的输出。导致我们的代码难以被调试、数据变化难以被追溯、计算结果难以被复用等等。

如：单元测试的主要判断的依据就是函数的输入和输出。如果对于同样的输入，函数不能够给到确定的输出，测试的难度将会陡然上升。

#### 纯函数，没有副作用的函数

消除副作用，足以解决函数中大多数的不确定性。此外，副作用的消除还解决了并行计算带来的竞争问题。而纯函数的计算完全发生在函数的内部，它不会对外部资源产生任何影响，因此纯函数的并行计算总是安全的。

如：A 函数和 B 函数都需要向某个文件写入信息，一旦我们先后调用了 A、B 两个函数，就将触发两个并行的写入过程，进入混乱的竞争态。

#### 纯函数，更加灵活的函数

如引入了外部变量的 add 函数，它的执行依赖函数的运行环境，一旦脱离了这个上下文，就会失去预期中的效用。
纯函数则完全不存在这个弊端，因为它除了入参谁也不认，除了计算啥也不干，它的计算逻辑在任何上下文里都是成立的。

```js
//假如我们将 add() 函数导出到一个没有 a 变量，或者 a 变量类型不为数字的上下文里，那么这个函数将当场失控。

let a = 1;

function add(x) {
  return a + x;
}

// 输出 3
add(2);

a = 10;

// 输出 12
add(2);
```

#### 纯函数可以改善代码质量

从研发效率上来看，纯函数的实践，实际上是将程序的“外部影响”和“内部计算”解耦了。这间接地促成了程序逻辑的分层，将会使得模块的功能更加内聚，即计算与副作用分离。计算是确定性的行为，而副作用则充满了不确定性。这一实践，本质上也是在贯彻“变与不变分离”的设计原则。

### 副作用不是毒药

对于纯函数来说，副作用无疑是地雷、是毒药。但对于一个完整的程序来说，副作用却至关重要。函数生产的是数据，这些数据要想作用于外部世界、创造一些真正的改变，就必须借助副作用。

### 总结

纯函数的这些规则并不是为了约束而约束，而是为了追求更高的确定性；同时引导我们做更加合理的逻辑分层，写出更加清晰、更善于应对变化的代码。
